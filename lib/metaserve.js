#!/usr/bin/env node
// Generated by CoffeeScript 2.4.1
(function() {
  //!/usr/bin/env coffee
  var CONFIG_FILE, CSS_COMPILER, DEFAULT_COMPILERS, DEFAULT_STATIC_DIR, HOST, HTML_COMPILER, IS_SPECIFIC_CONFIG, JS_COMPILER, PORT, STATIC_DIR, VERBOSE, app, argv, compilers, config, de_res, defaults, e, express, file_path, fs, isArray, isString, metaserve_compile, metaserve_middleware, path, url, util;

  fs = require('fs');

  url = require('url');

  util = require('util');

  path = require('path');

  // Reduce timestamp resolution from ms to s for last-modified
  de_res = function(n) {
    return Math.floor(n / 1000) * 1000;
  };

  // IsA helpers
  isArray = function(a) {
    return Array.isArray(a);
  };

  isString = function(s) {
    return typeof s === 'string';
  };

  // Set unset values of an object from a default object
  defaults = function(o, d) {
    var k, o_, v;
    o_ = {};
    for (k in o) {
      v = o[k];
      o_[k] = v;
    }
    for (k in d) {
      v = d[k];
      if (o[k] == null) {
        o_[k] = v;
      }
    }
    return o_;
  };

  // Default config
  VERBOSE = process.env.METASERVE_VERBOSE != null;

  DEFAULT_STATIC_DIR = '.';

  DEFAULT_COMPILERS = {
    html: require('metaserve-html-pug'),
    js: require('metaserve-js-coffee-reactify'),
    css: require('metaserve-css-postcss')
  };

  // Middleware for use in Express app
  module.exports = metaserve_middleware = function(config = {}, compilers = {}) {
    // Support both metaserve(static_dir) and metaserve(config) syntax
    if (isString(config)) {
      config = {
        static_dir: config
      };
    }
    // Fill in default config
    compilers = defaults(compilers, DEFAULT_COMPILERS);
    config.static_dir || (config.static_dir = DEFAULT_STATIC_DIR);
    return function(req, res, next) {
      var file_path;
      file_path = url.parse(req.url).pathname;
      // Translate directory requests to index.html requests
      if (file_path.slice(-1)[0] === '/') {
        file_path += 'index.html';
      }
      return metaserve_compile(compilers, file_path, config, {req}, function(err, response) {
        var filename;
        if (err) {
          return res.send(500, err);
        } else if (typeof response === 'string') {
          if (file_path.endsWith('.js')) {
            res.setHeader('Content-Type', 'application/javascript');
          } else if (file_path.endsWith('.css')) {
            res.setHeader('Content-Type', 'text/css');
          } else if (file_path.endsWith('.html')) {
            res.setHeader('Content-Type', 'text/html');
          }
          return res.end(response);
        } else if (response != null ? response.compiled : void 0) {
          if (response.content_type) {
            res.setHeader('Content-Type', response.content_type);
          }
          return res.end(response.compiled);
        } else {
          // If all else fails just use express's res.sendFile
          filename = config.static_dir + file_path;
          if (fs.existsSync(filename)) {
            if (VERBOSE) {
              console.log('[normalserve] Falling back with ' + filename);
            }
            return res.sendFile(filename, {
              root: process.cwd()
            });
          } else {
            if (VERBOSE) {
              console.log('[normalserve] Could not find ' + filename);
            }
            return next();
          }
        }
      });
    };
  };

  // Compiling a given a set of compilers, file, and config
  metaserve_compile = function(all_compilers, file_path, config, context, cb) {
    var compiler, compiler_config, compiler_context, compilers, ext, filename, filename_stem, i, len, matched, path_match, static_dir;
    if (VERBOSE) {
      console.log('[metaserve_compile] file_path=', file_path, 'config=', config);
    }
// Loop through each of the file types to see if the url matches
    for (path_match in all_compilers) {
      compilers = all_compilers[path_match];
      if (path_match === '*') {
        path_match = '.*';
      } else if (!path_match.match('\/')) {
        path_match = '\/(.*)\.' + path_match;
      }
      path_match = new RegExp(path_match);
      if (!isArray(compilers)) {
        // Compilers may be singular or a prioritized array
        compilers = [compilers];
      }
      compilers = compilers.filter(function(c) {
        return c != null; // Filter out non-compilers
      });
      
      // If it's a compileable file type...
      if (matched = file_path.match(path_match)) {
// Loop through the sources
        for (i = 0, len = compilers.length; i < len; i++) {
          compiler = compilers[i];
          // Build the corresponding source file's filename
          ext = compiler.ext;
          static_dir = config.static_dir || '.';
          filename_stem = matched[1];
          // If ext is "+something", add onto the path
          if (ext[0] === '+') {
            filename = path.join(static_dir, file_path + '.' + ext.slice(1));
          } else {
            // Otherwise replace existing extension
            filename = path.join(static_dir, filename_stem + '.' + ext);
          }
          // Try finding and compiling the source file
          if (fs.existsSync(filename)) {
            // Set up config to pass to compiler
            compiler_config = defaults(config[ext] || {}, compiler.default_config);
            compiler_config.bouncing = config.bouncing;
            compiler_config.static_dir = static_dir;
            compiler_context = Object.assign({}, config.globals, context);
            if (compiler.shouldCompile != null) {
              if (!compiler.shouldCompile(filename, compiler_config, compiler_context)) {
                if (VERBOSE) {
                  console.log(`[metaserve] Skipping compiler for ${filename}`);
                }
                continue;
              }
            }
            if (VERBOSE) {
              // Execute the compiler and let it handle the rest
              console.log(`[metaserve] Using compiler for ${file_path} (${filename})`);
            }
            return compiler.compile(filename, compiler_config, compiler_context, cb);
          } else {
            if (VERBOSE) {
              console.log(`[metaserve] File not found for ${filename}`);
            }
          }
        }
      }
    }
    // Fallback if nothing matched
    return cb(null);
  };

  // Stand-alone mode
  if (require.main === module) {
    express = require('express');
    argv = require('minimist')(process.argv);
    HOST = argv.host || process.env.METASERVE_HOST || '0.0.0.0';
    PORT = argv.port || process.env.METASERVE_PORT || 8000;
    STATIC_DIR = argv['static-dir'] || process.env.METASERVE_STATIC_DIR || '.';
    // Use a specific config or config.json
    CONFIG_FILE = argv.c || argv.config;
    IS_SPECIFIC_CONFIG = CONFIG_FILE != null;
    CONFIG_FILE || (CONFIG_FILE = 'config.json');
    try {
      config = JSON.parse(fs.readFileSync(CONFIG_FILE, 'utf8'));
      if (VERBOSE) {
        console.log("Using config:", util.inspect(config, {
          depth: null,
          colors: true
        }));
      }
    } catch (error) {
      e = error;
      if (IS_SPECIFIC_CONFIG) { // Only error if specific config fails
        console.log(`Could not read config: ${CONFIG_FILE}`);
        process.exit(1);
      } else {
        config = {};
      }
    }
    config.static_dir || (config.static_dir = STATIC_DIR);
    HTML_COMPILER = argv.html || 'pug';
    JS_COMPILER = argv.js || 'coffee-reactify';
    CSS_COMPILER = argv.css || 'postcss';
    compilers = {
      html: require(`metaserve-html-${HTML_COMPILER}`),
      js: require(`metaserve-js-${JS_COMPILER}`),
      css: require(`metaserve-css-${CSS_COMPILER}`)
    };
    // Bounce the file_path passed with the --bounce flag
    if (file_path = argv.bounce) {
      if (!file_path.startsWith('/')) {
        file_path = '/' + file_path;
      }
      config.bouncing = true;
      metaserve_compile(compilers, file_path, config, {}, function(err, response) {
        var bounced_filename;
        if ((response != null ? response.compiled : void 0) != null) {
          if (typeof argv.out === 'boolean') { // No output filename, just print it
            return console.log(response.compiled);
          } else {
            bounced_filename = argv.out || path.join(config.static_dir, file_path + '.bounced');
            fs.writeFileSync(bounced_filename, response.compiled);
            return console.log(`[metaserve] Bounced to ${bounced_filename}`);
          }
        } else if (err != null) {
          return console.log("[metaserve] Bouncing failed", err);
        } else {
          return console.log(`[metaserve] Bouncing failed, make sure path ${file_path} exists`);
        }
      });
    } else {
      app = express();
      app.use(function(req, res, next) {
        console.log(`[${req.method}] ${req.path}`);
        return next();
      });
      app.use(metaserve_middleware(config, compilers));
      app.listen(PORT, HOST, function() {
        return console.log(`Metaserving on http://${HOST}:${PORT}/`);
      });
    }
  }

}).call(this);
